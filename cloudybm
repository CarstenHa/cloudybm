#!/bin/bash

# Pfad zur Datei bookmarks.txt
if [ -z "$remotepath" ]; then
 if [ "$(find ~ -path ~/.Trash* -prune -or -name "bookmarks.txt" -print | wc -l)" == 1 ]; then
  remotepath="$(dirname "$(find ~ -path ~/.Trash* -prune -or -name "bookmarks.txt" -print)")"
 else
  logger -s --id=$$ "Pfad für Variable remotepath konnte nicht eindeutig ermittelt werden."
  exit 1
 fi
fi

makebackup() {
 echo "Sicherung wird erstellt ..."
 cp -vf "${remotepath}/bookmarks.txt" "${remotepath}/bookmarks.bak" && posbackup="yes"
}

usage() {
cat <<EOU

Skript zum Auflisten, Hinzufügen und Löschen von Lesezeichen.

$0 [-h]
$0 [-B] [KEYWORDS[,...]] [DESC] URI
$0 [-d] NUM
$0 [-s] SUCHWORT

Weitere Beispiele:
Beispiel 1: Durchsucht bookmarks.txt nach SUCHWORT und startet danach eine Abfrage, 
            welche Zeilen gelöscht werden sollen.
            $0 -s SUCHWORT -d ?
Beispiel 2: Löscht mehrere Zeilen in einem Rutsch.
            $0 -d NUM -d NUM -d NUM

Optionen:

   -B [KEYWORDS[,...]] [DESC] URI

	Fügt ein neues Lesezeichen der Datei bookmarks.txt hinzu.
	Schlüsselwörter und Beschreibung sind optional. Die Angabe einer URI ist erforderlich.
	Beispiele:
	$0 -B "Wort1,Wort2,etc." "Hier steht die Beschreibung" "https://example.com"
	$0 -B "" "" "https://example.com"

   -d NUM

	Löscht die angegebene Zeile aus bookmarks.txt.
	Als NUM muss die DB-POS angegeben werden (siehe Ausgabe der Option -s).
	Diese Option kann auch mehrmals angegeben werden, um mehrere Zeilen in einem Rutsch
	zu löschen (siehe Beispiel 2 oben).

   -e

	wendet die URI-Kodierung auf die URIs in der Datei bookmarks.txt an.
	Bestimmte Zeichen werden in Prozentkodierung geändert.
	Diese Option kann angewendet werden, wenn Einträge in bookmarks.txt "von Hand"
	vorgenommen wurden und es Probleme bei der Auswertung des Inhalts auf dem Client-Rechner
	gibt.

   -h

	ruft diese Hilfe auf.

   -s SUCHWORT

	durchsucht bookmarks.txt auf dem Server und gibt Ergebnis im Terminal aus.
	Beispiele:
	$0 -s "wort1\|wort2" : Findet Einträge mit wort1 oder wort2
	$0 -s "teil1.*teil2" : Findet String von teil1 bis teil2 (auch Spaltenübergreifend)
	$0 -s "go.gle"       : Findet Einträge mit goigle, goagle, gougle, usw.

Exitcodes:

0 - Keine Fehler (z.B. Erfolgreiches Hinzufügen eines Lesezeichens.)
1 - Variable remotepath ist leer.
    Die Datei bookmarks.txt konnte nicht eindeutig ermittelt werden.
2 - URI ist bereits in bookmarks.txt vorhanden.
    Es wird kein neues Lesezeichen eingetragen.
3 - Keine gültige URI.
    Es werden nur Einträge aufgenommen, die die Zeichen :// enthalten.
4 - Kein Lesezeichen gefunden.
5 - Fehlerhafte Einleitung des Löschvorgangs (Keine aktive Terminalsitzung für Abfrage).
6 - Fehler beim Löschvorgang (Fehleranalyse siehe journalctl).


EOU
}

impbmfile() {
 [ ! "$posbackup" == "yes" ] && makebackup
 #Noch auf .html/.htm-Suffix prüfen?
 while [ ! -e "$bmfile" ]; do
  read -p "Bitte eine Boookmark-HTML-Seite angeben: " bmfile
 done
 bmlist="$(sed -n 's/^.*\(<A.*<\/A>\).*$/\1/p' "$bmfile")"

 # Ist notwendig, wenn z.B. ven -B mit newbookmark von remote ausgerufen wird.
 ttycheck="$(tty -s; echo $?)"
 # Notwendig, weil Abfrage in Schleife stattfindet und aus here-String gelesen wird.
 term=$(tty)
 while read -r singlebm; do

  bmlinkraw="$(echo "$singlebm" | grep -o 'HREF="[^"]*"' | sed 's/^HREF="\(.*\)"/\1/')"
  # Encoding der URIs
  # Identisch mit Encoding in newbookmark
  bmlink="$(echo "$bmlinkraw" | sed '
                                     s/ /%20/g
                                     s/"/%22/g
                                     s/&/%26/g
                                     s/'\''/%27/g
                                     s/(/%28/g
                                     s/)/%29/g
                                     s/;/%3B/g
                                     s/</%3C/g
                                     s/>/%3E/g
                                     s/\[/%5B/g
                                     s/]/%5D/g
                                     s/{/%7B/g
                                     s/}/%7D/g
                                     s/|/%7C/g
                                     # Wenn kein Querystring, dann alle Pluszeichen mit %2B kodieren.
                                     /\?/!s/\+/%2B/g
                                     # Hier wird das Pluszeichen kodiert: Vor einem Query-String als %2B
                                     #                                    Als Teil eines Query-Strings als Leerzeichen (%20)
                                     /\?/{h; s/\?.*//; s/\+/%2B/g; x; s/^[^?]*?//; s/\+/%20/g; H; g; s/\n/?/}
                                     # Das ? muss als letztes verarbeitet werden, da es oben zur Auswertung
                                     # genutzt wird.
                                     s/\?/%3F/g
                                    ')"
  # Wichtig für korrekte Suche das $ im grep-Befehl (auch bei Variable bmlinenr).
  oldbmlink="$(cat "${remotepath}/bookmarks.txt" 2>/dev/null | grep -P ''"${bmlink}"'($|\t)')"
  bmtags="$(echo "$singlebm" | grep -o 'TAGS="[^"]*"' | sed 's/^TAGS="\(.*\)"/\1/')"
  bmdesc="$(echo "$singlebm" | sed 's/.*>\(.*\)<\/A>/\1/')"

  if [ -n "$oldbmlink" ]; then
   bmlinenr="$(cat "${remotepath}/bookmarks.txt" 2>/dev/null | grep -n "${bmlink}$" | grep -o '^[0-9]*')"
   echo "Identische Verlinkung in bookmarks.txt gefunden (Zeile: ${bmlinenr})."
   currentline="$(sed -n ''$bmlinenr'p' "${remotepath}/bookmarks.txt")"
   oldbmtags="$(echo "$currentline" | cut -f1)"
   oldbmdesc="$(echo "$currentline" | cut -f2)"
   if [ "$bmtags" == "$oldbmtags" -a "$bmdesc" == "$oldbmdesc" ]; then
    echo "Inhalte sind identisch."
   else
    echo "[B] ${currentline}"
    echo "[N] ${bmtags}	${bmdesc}	${bmlink}"
    while true; do
     # Ist notwendig, wenn z.B. ven -B mit newbookmark von remote ausgerufen wird.
     if [ "$ttycheck" -gt 0 ]; then
      logger -s --id=$$ "Lesezeichen mit der URI ${bmlink##*/} ist bereits in Zeile ${bmlinenr} vorhanden."
      venexit=2
      break
     else
      read -p "[B]estehende Zeile belassen oder [N]eue aufnehmen? " bmanswer <"$term"
     fi
     case "$bmanswer" in
       B|b) echo "Bestehender Eintrag in bookmarks.txt bleibt erhalten."
          break
          ;;
       n|N) echo "Alte Zeile ${bmlinenr} wird gelöscht und neuer Inhalt aufgenommen."
            sed -i ''"${bmlinenr}"'d' "${remotepath}/bookmarks.txt" && \
            echo "${bmtags}	${bmdesc}	${bmlink}" >>"${remotepath}/bookmarks.txt"
          break
          ;;
         *) echo "Fehlerhafte Eingabe!"
          ;;
     esac
    done
   fi
  else
   echo "${bmtags}	${bmdesc}	${bmlink}" >>"${remotepath}/bookmarks.txt"
   venexit=0
  fi

 done <<<"$bmlist"
 # Leerzeilen werden entfernt.
 sed -i '/^$/d' "${remotepath}/bookmarks.txt"
}
pprintbm() {
 if [ -n "$blist" ]; then
  bmcounter=0
  while IFS= read -r sbm; do
   let bmcounter++
   printf "\e[1mBookmark %.5d  :\e[0m DB-POS %d\n" "$bmcounter" "$(echo "$sbm" | cut -f1 | grep -o '^[0-9]*')"
   printf 'Schlüsselwörter : %s\n' "$(echo "$sbm" | cut -f1 | sed 's/^[0-9]*://')"
   printf 'Beschreibung    : %s\n' "$(echo "$sbm" | cut -f2)"
   # Bestimmte Zeichen werden hier wieder dekodiert.
   printf 'URI             : %s\n' "$(echo "$sbm" | cut -f3 | sed '
                                                                   s/%26/\&/g
                                                                   s/%3F/?/g
                                                                  ')"
   printf %"$(tput cols)"s | tr " " "-"
  done <<<"$blist"
 else
  echo "Kein Lesezeichen gefunden."
  venexit=4
 fi
}

while getopts Bd:ehs: opt; do
 case $opt in
   B) # Neues Lesezeichen hinzufügen
      shift $(("$OPTIND"-1))
      [ -z "$(echo "$3" | grep '://')" ] && logger -s --id=$$ "Keine gültige URI." && exit 3
      tfile=$(mktemp)
      echo "<DT><A HREF=\"${3}\" ADD_DATE=\"$(date '+%s')\" LAST_MODIFIED=\"$(date '+%s')\" TAGS=\"${1}\">${2}</A>" >"$tfile"
      bmfile="$tfile"
      impbmfile
      rm -f "$tfile"
      break
   ;;
   d) # Lesezeichen löschen
      deletebm="yes"
      if [ "$OPTARG" == "?" ]; then
       asknr="yes"
      else
       delbm+=("$OPTARG")
      fi
   ;;
   e) # Encoding URIs in bookmarks.txt
      [ ! "$posbackup" == "yes" ] && makebackup

      firstfilepart="$(cut -f1,2 "${remotepath}/bookmarks.txt")"
      secfilepart="$(cut -f3 "${remotepath}/bookmarks.txt" | sed '
                                     s/ /%20/g
                                     s/"/%22/g
                                     s/&/%26/g
                                     s/'\''/%27/g
                                     s/(/%28/g
                                     s/)/%29/g
                                     s/;/%3B/g
                                     s/</%3C/g
                                     s/>/%3E/g
                                     s/\[/%5B/g
                                     s/]/%5D/g
                                     s/{/%7B/g
                                     s/}/%7D/g
                                     s/|/%7C/g
                                     # Wenn kein Querystring, dann alle Pluszeichen mit %2B kodieren.
                                     /\?/!s/\+/%2B/g
                                     # Hier wird das Pluszeichen kodiert: Vor einem Query-String als %2B
                                     #                                    Als Teil eines Query-Strings als Leerzeichen (%20)
                                     /\?/{h; s/\?.*//; s/\+/%2B/g; x; s/^[^?]*?//; s/\+/%20/g; H; g; s/\n/?/}
                                     # Das ? muss als letztes verarbeitet werden, da es oben zur Auswertung
                                     # genutzt wird.
                                     s/\?/%3F/g
                                                                 ')"
       # Datei wird neu erstellt.
       paste -d'\t' <(echo "$firstfilepart") <(echo "$secfilepart") >"${remotepath}/bookmarks.txt"
       if [ "$(md5sum "${remotepath}/bookmarks.bak" | awk '{print $1}')" == "$(md5sum "${remotepath}/bookmarks.txt" | awk '{print $1}')" ]; then
        echo "Keine Änderungen an Datei bookmarks.txt vorgenommen."
       else
        echo "Änderungen bookmarks.bak < > bookmarks.txt:"
        diff "${remotepath}/bookmarks.bak" "${remotepath}/bookmarks.txt"
       fi
   ;;
   h) usage
      exit
   ;;
   s) # Bookmarks durchsuchen
      blist="$(grep -ni "${OPTARG}" "${remotepath}/bookmarks.txt")"

      # Formatierte Ausgabe bei aktivem Terminal.
      if [ "$(tty -s; echo $?)" == 0 ]; then

       pprintbm

      else

       if [ -n "$blist" ]; then
        echo "$blist"
       else
        echo "Kein Lesezeichen gefunden."
        venexit=4
       fi

      fi
   ;;
 esac
done

if [ "$deletebm" == "yes" ]; then

 if [ "$asknr" == "yes" -a "$(tty -s; echo $?)" == 0 ]; then
  echo "Angabe der Zeilennummer(n), die in der bookmarks.txt gelöscht werden soll(en) (Mehrfachangaben durch Leerzeichen getrennt sind möglich)."
  read -p "Bitte eingeben: " delline
  delbm=($delline)
 elif [ "$asknr" == "yes" -a ! "$(tty -s; echo $?)" == 0 ]; then
  logger -s --id=$$ "Keine aktive Terminalsitzung."
  exit 5
 fi

 if [ -n "$delbm" ]; then

  # Sicherung wird erstellt.
  [ ! "$posbackup" == "yes" ] && makebackup
  # Array wird ggf. sortiert, damit Zeilennummern richtig erhalten bleiben und vom Ende beginnend gelöscht wird.
  [ ${#delbm[@]} -gt 1 ] && delbm=($(printf '%s\n' "${delbm[@]}" | sort -nr | tr '\n' ' '))
  for delitem in "${delbm[@]}"; do
   if [[ "$delitem" =~ ^[0-9]*$ ]]; then
    if [ -n "$(sed -n ''"$delitem"'p' "${remotepath}/bookmarks.txt")" ]; then
     sed -i ''"$delitem"'d' "${remotepath}/bookmarks.txt" && echo "Zeile ${delitem} gelöscht."
    else
     logger -s --id=$$ "Zeile ${delitem} zum Löschen nicht gefunden."
     venexit=6
    fi
   else
    logger -s --id=$$ "Ungültige Angabe (${delitem})."
    venexit=6
   fi
  done

 fi

fi

[ -z "$venexit" ] && venexit=0
exit "$venexit"
